<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Live View</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f9f9f9;
        }

        h1 {
            margin-bottom: 20px;
        }

        .controls {
            margin: 20px;
        }

        .controls button, .controls a {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            margin-right: 10px;
            text-decoration: none;
            background-color: #007bff;
            color: white;
            border-radius: 5px;
        }

        .chart-container {
            width: 100%; /* Charts occupy full width */
            max-width: 100%; /* Prevent horizontal scrolling */
            margin: 20px 0;
            height: 400px; /* Default height */
            transition: height 0.3s ease, width 0.3s ease; /* Smooth transitions */
        }

        .slim .chart-container {
            height: 200px; /* Slim mode height */
        }

        canvas {
            display: block;
            width: 100%; /* Canvas stretches to container width */
            height: 100%; /* Canvas fills container height */
        }
    </style>
</head>
<body>
    <h1>Live Data Visualization</h1>
    <div class="controls">
        <a href="/settings">Settings</a>
        <a href="/viewer">Viewer</a>
        <button id="pause">Pause</button>
        <button id="resume" style="display:none;">Resume</button>
        <button id="resetZoom">Reset Zoom</button>
        <a href="/save">Save to File</a>
        <button id="toggleHeight">Slim</button>
    </div>
    <div class="chart-container">
        <canvas id="mbitChart"></canvas>
    </div>
    <div class="chart-container">
        <canvas id="rssiChart"></canvas>
    </div>
    <div class="chart-container">
        <canvas id="snrChart"></canvas>
    </div>
    <div class="chart-container">
        <canvas id="redundancyChart"></canvas>
    </div>
    <div class="chart-container">
        <canvas id="derivativeChart"></canvas>
    </div>

    <script>
        let paused = false;

        const mbitCtx = document.getElementById('mbitChart').getContext('2d');
        const rssiCtx = document.getElementById('rssiChart').getContext('2d');
        const snrCtx = document.getElementById('snrChart').getContext('2d');
        const redundancyCtx = document.getElementById('redundancyChart').getContext('2d');
        const derivativeCtx = document.getElementById('derivativeChart').getContext('2d');

        const zoomOptions = {
            pan: {
                enabled: true,
                mode: 'x',
            },
            zoom: {
                wheel: {
                    enabled: true,
                },
                pinch: {
                    enabled: true,
                },
                mode: 'x',
            },
        };

        const mbitChart = new Chart(mbitCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [
                    { label: 'All Bytes (Mbit/s)', data: [], borderColor: 'red', fill: false },
                    { label: 'Out Bytes (Mbit/s)', data: [], borderColor: 'blue', fill: false },
                ],
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                elements: { point: { radius: 0 } },
                scales: {
                    y: { min: 0, max: 100 }, // Default values, updated dynamically
                },
                plugins: { legend: { display: true }, zoom: zoomOptions },
            },
        });

        const rssiChart = new Chart(rssiCtx, {
            type: 'line',
            data: { labels: [], datasets: [] },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                elements: { point: { radius: 0 } },
                scales: { y: { beginAtZero: true, max: 1 } },
                plugins: { legend: { display: true }, zoom: zoomOptions },
            },
        });

        const snrChart = new Chart(snrCtx, {
            type: 'line',
            data: { labels: [], datasets: [] },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                elements: { point: { radius: 0 } },
                scales: { y: { beginAtZero: true, max: 1 } },
                plugins: { legend: { display: true }, zoom: zoomOptions },
            },
        });

        const redundancyChart = new Chart(redundancyCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [
                    { label: 'Redundancy', data: [], borderColor: 'green', fill: false },
                ],
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                elements: { point: { radius: 0 } },
                scales: { y: { beginAtZero: true, max: 6 } },
                plugins: { legend: { display: true }, zoom: zoomOptions },
            },
        });

        const derivativeChart = new Chart(derivativeCtx, {
            type: 'line',
            data: {
                labels: [],
                datasets: [
                    { label: 'Derivative', data: [], borderColor: 'blue', fill: false },
                    { label: 'FEC_REC', data: [], borderColor: 'purple', fill: false },
                    { label: 'LOST', data: [], borderColor: 'orange', fill: false },
                ],
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                elements: { point: { radius: 0 } },
                scales: { y: { min: -2, max: 2 } },
                plugins: { legend: { display: true }, zoom: zoomOptions },
            },
        });

        function updateYAxisLimits(chart, min, max) {
            chart.options.scales.y.min = min;
            chart.options.scales.y.max = max;
            chart.update();
        }

        function fetchData() {
            if (paused) return;
            fetch('/data')
                .then((response) => response.json())
                .then((data) => {
                    const { rssi, snr, redundancy, derivative, fec_rec, lost, all_mbit, out_mbit, sample_indices, colors, settings } = data;

                    // Update Y-axis limits for Mbit/s chart
                    updateYAxisLimits(mbitChart, settings.MBIT_MIN, settings.MBIT_MAX);

                    // Update Mbit/s Chart
                    mbitChart.data.labels = sample_indices;
                    mbitChart.data.datasets[0].data = all_mbit;
                    mbitChart.data.datasets[1].data = out_mbit;
                    mbitChart.update();

                    // Update RSSI Chart
                    updateChart(rssiChart, rssi, sample_indices, colors);

                    // Update SNR Chart
                    updateChart(snrChart, snr, sample_indices, colors);

                    // Update Redundancy Chart
                    redundancyChart.data.labels = sample_indices;
                    redundancyChart.data.datasets[0].data = redundancy;
                    redundancyChart.update();

                    // Update Derivative Chart
                    derivativeChart.data.labels = sample_indices;
                    derivativeChart.data.datasets[0].data = derivative;
                    derivativeChart.data.datasets[1].data = fec_rec;
                    derivativeChart.data.datasets[2].data = lost;
                    derivativeChart.update();
                });
        }

        function updateChart(chart, data, labels, colors) {
            chart.data.labels = labels;
            chart.data.datasets = [];
            for (const [key, values] of Object.entries(data)) {
                chart.data.datasets.push({
                    label: key,
                    data: values,
                    borderColor: colors[key],
                    fill: false,
                });
            }
            chart.update();
        }

        document.getElementById('toggleHeight').addEventListener('click', () => {
            document.body.classList.toggle('slim');
            mbitChart.update();
            rssiChart.update();
            snrChart.update();
            redundancyChart.update();
            derivativeChart.update();
            document.getElementById('toggleHeight').textContent = document.body.classList.contains('slim') ? 'Normal' : 'Slim';
        });

        document.getElementById('pause').addEventListener('click', () => {
            paused = true;
            document.getElementById('pause').style.display = 'none';
            document.getElementById('resume').style.display = 'inline';
        });

        document.getElementById('resume').addEventListener('click', () => {
            paused = false;
            document.getElementById('resume').style.display = 'none';
            document.getElementById('pause').style.display = 'inline';
        });

        document.getElementById('resetZoom').addEventListener('click', () => {
            mbitChart.resetZoom();
            rssiChart.resetZoom();
            snrChart.resetZoom();
            redundancyChart.resetZoom();
            derivativeChart.resetZoom();
        });

        setInterval(fetchData, 500);
    </script>


<head>
  <meta charset="utf-8" />
  <title>Remote Command Control</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
    }
    .cmdButton {
      margin: 4px;
      padding: 6px;
    }
    #logArea {
      width: 100%;
      height: 300px;
      background-color: #1e1e1e;
      color: #ddd;
      font-family: monospace;
      overflow-y: auto;
      white-space: pre-wrap;
      padding: 8px;
      border-radius: 4px;
      margin-bottom: 10px;
    }
    #statusIndicator {
      display: inline-block;
      width: 12px;
      height: 12px;
      border-radius: 50%;
      margin-right: 4px;
      vertical-align: middle;
      background-color: red; /* default: stopped */
    }
  </style>
</head>
<body>
  <h1>Remote Command Execution</h1>

  <!-- Status display -->
  <div>
    <span id="statusIndicator"></span>
    <span id="statusText">No command running</span>
  </div>

  <hr />

  <!-- Preset Commands -->
  <div>
    <button class="cmdButton" onclick="attemptStart('/usr/bin/extcmd_userscript1.sh')">Script 1</button>
    <button class="cmdButton" onclick="attemptStart('/usr/bin/extcmd_userscript2.sh')">Script 2</button>
    <button class="cmdButton" onclick="attemptStart('/usr/bin/extcmd_userscript3.sh')">Script 3</button>
    <button class="cmdButton" onclick="attemptStart('/usr/bin/extcmd_userscript4.sh')">Script 4</button>
    <button class="cmdButton" onclick="attemptStart('/usr/bin/extcmd_userscript5.sh')">Script 5</button>
    <button class="cmdButton" onclick="attemptStart('/usr/bin/extcmd_userscript6.sh')">Script 6</button>
  </div>

  <hr />

  <!-- Log window -->
  <pre id="logArea"></pre>

  <!-- Controls for input and stopping -->
  <input type="text" id="inputField" placeholder="Type input to send..." />
  <button onclick="sendInput()">Send</button>
  <button onclick="stopCommand()">Stop</button>
  <button onclick="clearLog()">Clear</button>

  <hr />

  <script>
    let eventSource = null;
    let isRunning = false; // Track current run state
    const statusText = document.getElementById('statusText');
    const statusIndicator = document.getElementById('statusIndicator');
    const logArea = document.getElementById('logArea');
    const inputField = document.getElementById('inputField');

    // 1) Attempt to start a command only if no command is running
    //    Otherwise, prompt the user or do nothing.
    function attemptStart(command) {
      if (isRunning) {
        alert("A command is already running. Please stop it first.");
        return;
      }
      startCommand(command);
    }

    // 2) Start a command
    function startCommand(command) {
      closeSSE(); // Just to be sure we reset any old connection
      fetch('/command/start', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({ command })
      })
      .then(r => r.json())
      .then(data => {
        if (!data.success) {
          alert("Error: " + data.message);
          return;
        }
        // Command started successfully, clear the log & open SSE
        clearLog();
        connectSSE();
        updateStatus(); // Refresh status info
      })
      .catch(err => console.error(err));
    }

    // 3) Stop the current command
    //    We'll do the graceful approach (SIGINT -> fallback -> SIGTERM).
    function stopCommand() {
      fetch('/command/stop', { method: 'POST' })
        .then(r => r.json())
        .then(data => {
          // Even if we got an error, we might still refresh status
          updateStatus();
        })
        .catch(err => console.error(err));
    }

    // 4) Send manual input (e.g., password) to stdin
    function sendInput() {
      const txt = inputField.value;
      if (!txt) return;

      fetch('/command/input', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ input: txt })
      })
      .then(r => r.json())
      .then(data => {
        if (!data.success) {
          alert("Error: " + data.message);
        } else {
          // Optionally clear the input
          inputField.value = '';
        }
      });
    }

    // 5) SSE for real-time log updates
    function connectSSE() {
      eventSource = new EventSource('/command/stream');

      eventSource.onmessage = (evt) => {
        // Append data to the log area
        logArea.textContent += evt.data + "\n";
        logArea.scrollTop = logArea.scrollHeight;
      };

      eventSource.onerror = (evt) => {
        // SSE can error out if the server closes the connection or network issues
        console.warn("SSE error", evt);
      };
    }

    // Clean up SSE connection
    function closeSSE() {
      if (eventSource) {
        eventSource.close();
        eventSource = null;
      }
    }

    // 6) Clear the log
    function clearLog() {
      logArea.textContent = "";
    }

    // 7) Periodic status update
    function updateStatus() {
      fetch('/command/status')
        .then(r => r.json())
        .then(info => {
          // info = { cmd, args, running, exit_code }
          isRunning = info.running;

          if (info.running) {
            statusIndicator.style.backgroundColor = 'green';
            const cmdStr = [info.cmd, ...(info.args || [])].join(' ');
            statusText.textContent = `Running: ${cmdStr}`;

            // If no SSE is open, reconnect
            if (!eventSource) {
              connectSSE();
            }
          } else {
            statusIndicator.style.backgroundColor = 'red';
            statusText.textContent = `Stopped (exit code: ${info.exit_code})`;

            // If the SSE is still open, close it
            closeSSE();
          }
        })
        .catch(err => console.error(err));
    }

    // 8) Poll status at intervals (e.g., every 2s)
    setInterval(updateStatus, 2000);

    // 9) On page load, do an initial status check
    document.addEventListener('DOMContentLoaded', () => {
      updateStatus();
    });
  </script>
</body>

</body>
</html>
